// plugin.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "IPlugin.h"
#include <math.h>
#include <stdlib.h>
////////////////////////////////////////////////////////////////////////
// A concrete plugin implementation
////////////////////////////////////////////////////////////////////////

// Photo-Reactor Plugin class

//****************************************************************************
//This code has been generated by the Mediachance photo reactor Code generator.


#define AddParameter(N,S,V,M1,M2,T,D) {strcpy (pParameters[N].m_sLabel,S);pParameters[N].m_dValue = V;pParameters[N].m_dMin = M1;pParameters[N].m_dMax = M2;pParameters[N].m_nType = T;pParameters[N].m_dSpecialValue = D;}

#define GetValue(N) (pParameters[N].m_dValue)
#define GetValueY(N) (pParameters[N].m_dSpecialValue)

#define SetValue(N,V) {pParameters[N].m_dValue = V;}

#define GetBOOLValue(N) ((BOOL)(pParameters[N].m_dValue==pParameters[N].m_dMax))

// if it is not defined, then here it is
//#define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))




//#define PARAM_BRIGHTNESS	0
#define NUMBER_OF_USER_PARAMS 0

class PluginTest : public IPlugin	
{
public:




	// constructor
	PluginTest()
	{



	}


		//Plugin Icon:
	//you can add your own icon by creating 160x100 png file, naming it the same as plugin dll and then placing it in the plugins folder
	//otherwise a generic icon will be used 

	//this is the title of the box in workspace. it should be short
	const char* GetTitle () const
	{
		return "!invert";
	}
	
	// this will appear in the help pane, you can put your credits and short info
	const char* GetDescription () const
	{
		return "inverts image";
	}

	// BASIC PARAMETERS
	// number of inputs 0,1 or 2
	int GetInputNumber ()
	{
		return 1;
	}

	// number of outputs 0 or 1
	int GetOutputNumber ()
	{
		return 1;
	}

	int GetBoxColor ()
	{
		return RGB(56,61,72);
	}

	int GetTextColor ()
	{
		return RGB(130,130,130);
	}

	// width of the box in the workspace
	// valid are between 50 and 100
	int GetBoxWidth ()
	{
		return 70;
	}

	// set the flags
	// see the interface builder
	// ex: nFlag = FLAG_FAST_PROCESS | FLAG_HELPER;

	//FLAG_NONE same as zero	Default, no other flags set
	//FLAG_UPDATE_IMMEDIATELY	It is very fast process that can update immediately. When user turns the sliders on UI the left display will update
	//							Use Update Immediately only for fast and single loop processes, for example Desaturate, Levels.
	//FLAG_HELPER				It is an helper object. Helper objects will remain visible in Devices and they can react to mouse messages. Example: Knob, Monitor, Bridge Pin
	//FLAG_BINDING				Binding object, attach to other objects and can change its binding value. It never goes to Process_Data functions.  Example: Knob, Switch, Slider
	//FLAG_DUMMY				It is only for interface but never process any data. Never goes to Process_Data functions. Example: Text note
	//FLAG_SKIPFINAL			Process data only during designing, doesn't process during final export. Example: Monitor, Vectorscope 
	//FLAG_LONGPROCESS			Process that takes > 1s to finish. Long Process will display the Progress dialog and will prevent user from changing values during the process.
	//FLAG_NEEDSIZEDATA		    Process need to know size of original image, the zoom and what part of image is visible in the preview. When set the plugin will receive SetSizeData
	//FLAG_NEEDMOUSE			Process will receive Mouse respond data from the workplace. This is only if your object is interactive, for example Knob, Slider
	
	// addition in 5/29/2013
	// very special case (BETA):
	//FLAG_GETMAINIMAGERGBA		Process_Data will always receive full Main Image as the input buffer in the UP RGBA format (! different than normal BGRA upside down buffer), 
	//							Needs GetInputNumber  = 0 as it doesn't process buffer from the input node at all. 

	int GetFlags ()
	{
		// it is fast process
		int nFlag = FLAG_NONE;

		nFlag = nFlag | FLAG_UPDATE_IMMEDIATELY;
		nFlag = nFlag | FLAG_HELPER;


		
		return nFlag;
	}


	// User Interface Build
	// there is maximum 29 Parameters

	int GetUIParameters (UIParameters* pParameters)
	{

		// label, value, min, max, type_of_control, special_value
		// use the UI builder in the software to generate this

		//AddParameter( PARAM_BRIGHTNESS ,"Brightness", 0.0, -1.0, 1.0, TYPE_SLIDER, 0.0);
		

		return NUMBER_OF_USER_PARAMS;
	}
	

	// Actual processing function for 1 input
	//***************************************************************************************************
	// Both buffers are the same size
	// don't change the IN buffer or things will go bad for other objects in random fashion
	// the pBGRA_out comes already with pre-copied data from pBGRA_in
	// Note: Don't assume the nWidth and nHeight will be every run the same or that it contains the whole image!!!! 
	// This function receives buffer of the actual preview (it can be just a crop of image when zoomed in) and during the final calculation of the full buffer
	virtual void Process_Data (BYTE* pBGRA_out,BYTE* pBGRA_in, int nWidth, int nHeight, UIParameters* pParameters)
	{
		// this is just example to desaturate and to adjust the desaturation with slider
		// Get the latest parameters

		//List of Parameters
		double fcolorspace = 255.0f;

		double* GammaEnhancedImage=new double[nWidth * nHeight * 4]; // this is our tempory array to hold the enhanced image

		//place our image in a seperate array in the 0-1 range, where 0 is darkest and 1 is lightest
		for (int x = 0; x < nWidth; x++)
		{
			for (int y = 0; y < nHeight; y++)
			{
					int nIdx = x * 4 + y * 4 * nWidth;
					double red = pBGRA_in[nIdx + CHANNEL_R] / fcolorspace;
					double green = pBGRA_in[nIdx + CHANNEL_G] / fcolorspace;
					double blue = pBGRA_in[nIdx + CHANNEL_B] / fcolorspace;

					double redinvert = 1 - red;
					double greeninvert = 1 - green;
					double blueinvert = 1 - blue;

					double redout = redinvert * fcolorspace;
					double greenout = greeninvert * fcolorspace;
					double blueout = blueinvert * fcolorspace;

					pBGRA_out[nIdx + CHANNEL_R] = CLAMP255(redout);
					pBGRA_out[nIdx + CHANNEL_G] = CLAMP255(greenout);
					pBGRA_out[nIdx + CHANNEL_B] = CLAMP255(blueout);
			}
		}


	}

	// actual processing function for 2 inputs
	//********************************************************************************
	// all buffers are the same size
	// don't change the IN buffers or things will go bad
	// the pBGRA_out comes already with copied data from pBGRA_in1
	virtual void Process_Data2 (BYTE* pBGRA_out, BYTE* pBGRA_in1, BYTE* pBGRA_in2, int nWidth, int nHeight, UIParameters* pParameters)
	{


/*

		if (ColorSpace == 1)
#pragma region          // using CIE LAB
		{
			for (int y = 0; y< nHeight; y++)
			{
				for (int x = 0; x< nWidth; x++)
				{
					int nIdx = x*4+y*4*nWidth;

					double red1;
					double green1;
					double blue1;
					double red2;
					double green2;
					double blue2;
					double xyzX1;
					double xyzY1;
					double xyzZ1;

					double xyzX2;
					double xyzY2;
					double xyzZ2;

					double var_X1;
					double var_Y1;
					double var_Z1;
					double var_X2;
					double var_Y2;
					double var_Z2;

					double refX;
					double refY;
					double refZ;

					double var_X11;
					double var_Y12;
					double var_Z13;
					double var_X21;
					double var_Y22;
					double var_Z23;

					//read in image 1
					red1   = double(pBGRA_in1[nIdx + CHANNEL_R]) / fcolorspace;
					green1 = double(pBGRA_in1[nIdx + CHANNEL_G]) / fcolorspace;
					blue1  = double(pBGRA_in1[nIdx + CHANNEL_B]) / fcolorspace;

					//read in image 2
					red2   = double(pBGRA_in2[nIdx + CHANNEL_R]) / fcolorspace;
					green2 = double(pBGRA_in2[nIdx + CHANNEL_G]) / fcolorspace;
					blue2  = double(pBGRA_in2[nIdx + CHANNEL_B]) / fcolorspace;

					//adjust gamma on image 1
					if (red1 > 0.04045f)
					{ 
						red1 = powf((red1 + 0.055f) / 1.055f, 2.4f); 
					}
					else 
					{ 
						red1 = red1 / 12.92f; 
					}
					if (green1 > 0.04045f)
					{ 
						green1 = powf((green1 + 0.055f) / 1.055f, 2.4f); 
					}
					else 
					{ 
						green1 = green1 / 12.92f; 
					}
					if (blue1 > 0.04045f)
					{ 
						blue1 = powf((blue1 + 0.055f) / 1.055f, 2.4f); 
					}
					else 
					{	
						blue1 = blue1 / 12.92f; 
					}

					if (red2 > 0.04045f)
					{ 
						red2 = powf((red2 + 0.055f) / 1.055f, 2.4f); 
					}
					else 
					{ 
						red2 = red2 / 12.92f; 
					}
					if ( green2 > 0.04045f)
					{ 
						green2 = powf((green2 + 0.055f) / 1.055f, 2.4f); 
					}
					else 
					{ 
						green2 = green2 / 12.92f; 
					}
					if (blue2 > 0.04045f)
					{ 
						blue2 = powf((blue2 + 0.055f) / 1.055f, 2.4f); 
					}
					else 
					{	
						blue2 = blue2 / 12.92f; 
					}


					//scale image 1
					red1   = red1   * 100.0f;
					green1 = green1 * 100.0f;
					blue1  = blue1  * 100.0f;
					//scale image 2
					red2   = red2   * 100.0f;
					green2 = green2 * 100.0f;
					blue2  = blue2  * 100.0f;

					//first we will convert the RGB image to XYZ
					//image 1
					xyzX1 = (0.412453f * red1) + (0.357580f * green1) + (0.180423f * blue1);
					xyzY1 = (0.212671f * red1) + (0.715160f * green1) + (0.072169f * blue1);
					xyzZ1 = (0.019334f * red1) + (0.119193f * green1) + (0.950227f * blue1);
					//image 2
					xyzX2 = (0.412453f * red2) + (0.357580f * green2) + (0.180423f * blue2);
					xyzY2 = (0.212671f * red2) + (0.715160f * green2) + (0.072169f * blue2);
					xyzZ2 = (0.019334f * red2) + (0.119193f * green2) + (0.950227f * blue2);

					//reference white
					refX = 95.047f; // Observer= 2°, Illuminant= D65
					refY = 100.000f; 
					refZ = 108.883f;

					//adjust LAB to reference white
					//image 1
					var_X1 = xyzX1 / refX;
					var_Y1 = xyzY1 / refY;
					var_Z1 = xyzZ1 / refZ;
					//image 2
					var_X2 = xyzX2 / refX;
					var_Y2 = xyzY2 / refY;
					var_Z2 = xyzZ2 / refZ;

					//LAB Conversion
					//image 1
					if (var_X1 > 0.008856f) 
					{
						var_X11 = powf(var_X1 , 1.0f/3.0f); 
					}
					else 
					{
						var_X11 = (7.787f * var_X1) + (16.0f/116.0f);
					}

					if (var_Y1 > 0.008856f) 
					{ 
						var_Y12 = powf(var_Y1 , 1.0f/3.0f); 
					}
					else 
					{ 
						var_Y12 = (7.787f * var_Y1) + (16.0f/116.0f);
					}

					if (var_Z1 > 0.008856f) 
					{
						var_Z13 = powf(var_Z1 , 1.0f/3.0f); 
					}
					else 
					{ 
						var_Z13 = (7.787f * var_Z1) + (16.0f/116.0f);
					}
					//image 2
					if (var_X2 > 0.008856f) 
					{
						var_X21 = powf(var_X2 , 1.0f/3.0f); 
					}
					else 
					{
						var_X21 = (7.787f * var_X2) + (16.0f/116.0f);
					}

					if (var_Y2 > 0.008856f) 
					{ 
						var_Y22 = powf(var_Y2 , 1.0f/3.0f); 
					}
					else 
					{ 
						var_Y22 = (7.787f * var_Y2) + (16.0f/116.0f);
					}

					if (var_Z2 > 0.008856f) 
					{
						var_Z23 = powf(var_Z2 , 1.0f/3.0f); 
					}
					else 
					{ 
						var_Z23 = (7.787f * var_Z2) + (16.0f/116.0f);
					}
 
					//adjust LAB scale
					//image 1
					double cieL1 = (116.0f * var_Y12) - 16.0f;
					double cieA1 = 500.0f * (var_X11 - var_Y12);
					double cieB1 = 200.0f * (var_Y12 - var_Z13);
					//image 2
					double cieL2 = (116.0f * var_Y22) - 16.0f;
					double cieA2 = 500.0f * (var_X21 - var_Y22);
					double cieB2 = 200.0f * (var_Y22 - var_Z23);


					//place LAB image in temp array
					targetImage[nIdx + CHANNEL_R] = cieL1;//int(cieL1);
					targetImage[nIdx + CHANNEL_G] = cieA1;//int(cieA1);
					targetImage[nIdx + CHANNEL_B] = cieB1;//int(cieB1);



					//place LAB image in temp array
					referenceImage[nIdx + CHANNEL_R] = cieL2;//int(cieL2);
					referenceImage[nIdx + CHANNEL_G] = cieA2;//int(cieA2);
					referenceImage[nIdx + CHANNEL_B] = cieB2;//int(cieB2);
				}
			}
		}
#pragma endregion



#pragma region			//test for proof that the image is in temp
		for (int x = 0; x< nWidth; x++)
		{
			for (int y = 0; y< nHeight; y++)
			{
					int nIdx = x * 4 + y * 4 * nWidth;
				
					//int nR = targetImage [nIdx + CHANNEL_R];
					//int nG = targetImage [nIdx + CHANNEL_G];
					//int nB = targetImage [nIdx + CHANNEL_B];

					//int nR = referenceImage [nIdx + CHANNEL_R];
					//int nG = referenceImage [nIdx + CHANNEL_G];
					//int nB = referenceImage [nIdx + CHANNEL_B];

					//pBGRA_out[nIdx + CHANNEL_R] = CLAMP255(nB);
					//pBGRA_out[nIdx + CHANNEL_G] = CLAMP255(nB);
					//pBGRA_out[nIdx + CHANNEL_B] = CLAMP255(nB);				
			}
		}
#pragma endregion


		if (ColorSpace == 1)
#pragma region			//CIE LAB
		{
			for (int x = 0; x< nWidth; x++)
			{
				for (int y = 0; y< nHeight; y++)
				{
					int nIdx = x * 4 + y * 4 * nWidth;

					double refX;
					double refY;
					double refZ;

					double var_X;
					double var_Y;
					double var_Z;

					double cieX;
					double cieY;
					double cieZ;

					double red;
					double green;
					double blue;

					//reference white
					refX = 95.047f; // Observer= 2°, Illuminant= D65
					refY = 100.000f; 
					refZ = 108.883f;

					double cieL = enhancedimage [nIdx + CHANNEL_R];
					double cieA = enhancedimage [nIdx + CHANNEL_G];
					double cieB = enhancedimage [nIdx + CHANNEL_B];

					var_Y = (cieL + 16.0f) / 116.0f;
					var_X = cieA / 500.0f + var_Y;
					var_Z = var_Y - cieB / 200.0f;

					if (powf(var_Y, 3.0f) > 0.008856)
					{ 
						var_Y = powf(var_Y, 3.0f); 
					}
					else 
					{ 
						var_Y = (var_Y - 16.0f / 116.0f) / 7.787f; 
					}
					if (powf(var_X , 3.0f) > 0.008856f) 
					{ 
						var_X = powf(var_X, 3.0f); 
					}
					else 
					{ 
						var_X = (var_X - 16.0f / 116.0f) / 7.787f; 
					}
					if (powf(var_Z, 3.0f) > 0.008856 ) 
					{
						var_Z = powf(var_Z, 3.0f); 
					}
					else 
					{
						var_Z = (var_Z - 16.0f / 116.0f ) / 7.787f; 
					}

					cieX = refX * var_X;
					cieY = refY * var_Y;
					cieZ = refZ * var_Z;

					var_X = cieX / 100.0f;        
					var_Y = cieY / 100.0f;        
					var_Z = cieZ / 100.0f;

					red   = (var_X * 3.240479f)  + (var_Y * -1.537150f) + (var_Z * -0.498535f);
					green = (var_X * -0.969256f) + (var_Y * 1.87599f)  + (var_Z * 0.041556f);
					blue  = (var_X * 0.055648f)  + (var_Y * -0.204043f) + (var_Z * 1.057311f);

					if (red > 0.0031308f) 
					{ 
						red = 1.055f * powf(red , (1.0f / 2.4f)) - 0.055f; 
					}
					else 
					{ 
						red = 12.92f * red; 
					}
					if (green > 0.0031308f) 
					{ 
						green = 1.055f * powf(green , (1.0f / 2.4f)) - 0.055f; 
					}
					else 
					{ 
						green = 12.92f * green; 
					}
					if (blue > 0.0031308f) 
					{ 
						blue = 1.055f * powf(blue , (1.0f / 2.4f)) - 0.055f; 
					}
					else 
					{
						blue = 12.92f * blue; 
					}
					

					red = CLAMP255(red * fcolorspace);
					green = CLAMP255(green * fcolorspace);
					blue = CLAMP255(blue * fcolorspace);

					enhancedimage[nIdx + CHANNEL_R] = red;
					enhancedimage[nIdx + CHANNEL_G] = green;
					enhancedimage[nIdx + CHANNEL_B] = blue;	
				}
			}
		}
#pragma endregion
		*/

	}


	//*****************Drawing functions for the BOX *********************************
	//how is the drawing handled
	//DRAW_AUTOMATICALLY	the main program will fully take care of this and draw a box, title, socket and thumbnail
	//DRAW_SIMPLE_A			will draw a box, title and sockets and call CustomDraw
	//DRAW_SIMPLE_B			will draw a box and sockets and call CustomDraw
	//DRAW_SOCKETSONLY      will call CustomDraw and then draw sockets on top of it
	
	// highlighting rectangle around is always drawn except for DRAW_SOCKETSONLY

	virtual int GetDrawingType ()
	{
		int nType = DRAW_AUTOMATICALLY;

		return nType;

	}


	// Custom Drawing
	// custom drawing function called when drawing type is different than DRAW_AUTOMATICALLY
	// it is not always in real pixels but scaled depending on where it is drawn
	// the scale could be from 1.0 to > 1.0
	// so you always multiply the position, sizes, font size, line width with the scale
	
	virtual void CustomDraw (HDC hDC, int nX,int nY, int nWidth, int nHeight, float scale, BOOL bIsHighlighted, UIParameters* pParameters)
	{

	}


	//************ Optional Functions *****************************************************************************************
	// those functions are not necessary for normal effect, they are mostly for special effects and objects


	// Called when FLAG_HELPER set. 
	// When UI data changed (user turned knob) this function will be called as soon as user finish channging the data
	// You will get the latest parameters and also which parameter changed
	// Normally for effects you don't have to do anything here because you will get the same parameters in the process function
	// It is only for helper objects that may not go to Process Data 
	BOOL UIParametersChanged (UIParameters* pParameters, int nParameter)
	{
		
		return FALSE;
	}

	// when button is pressed on UI, this function will be called with the parameter and sub button (for multi button line)
	BOOL UIButtonPushed (int nParam, int nSubButton, UIParameters* pParameters)
	{

		return TRUE;
	}

	// Called when FLAG_NEEDSIZEDATA set
	// Called before each calculation (Process_Data)
	// If your process depends on a position on a frame you may need the data to correctly display it because Process_Data receives only a preview crop
	// Most normal effects don't depend on the position in frame so you don't need the data
	// Example: drawing a circle at a certain position requires to know what is displayed in preview or the circle will be at the same size and position regardless of zoom
	
	// Note: Even if you need position but you don't want to mess with the crop data, just ignore it and pretend the Process_Data are always of full image (they are not). 
	// In worst case this affects only preview when using zoom. The full process image always sends the whole data

	// nOriginalW, nOriginalH - the size of the original - full image. If user sets Resize on input - this will be the resized image
	// nPreviewW, nPreviewH   - this is the currently processed preview width/height - it is the same that Process_Data will receive
	//                        - in full process the nPreviewW, nPreviewH is equal nOriginalW, nOriginalH
	// Crop X1,Y1,X2,Y2       - relative coordinates of preview crop rectangle in <0...1>, for full process they are 0,0,1,1 (full rectangle)	
	// dZoom                  - Zoom of the Preview, for full process the dZoom = 1.0
	void SetSizeData(int nOriginalW, int nOriginalH, int nPreviewW, int nPreviewH, double dCropX1, double dCropY1, double dCropX2, double dCropY2, double dZoom)
	{

		// so if you need the position and zoom, this is the place to get it.
		// Note: because of IBM wisdom the internal bitmaps are on PC always upside down, but the coordinates are not
		// which you  need to take into account. See rectangle demo project for more info 


	}


	// ***** Mouse handling on workplace *************************** 
	// only if FLAG_NEEDMOUSE is set
	//****************************************************************
	//this is for special objects that need to receive mouse, like a knob or slider on workplace
	// normally you use this for FLAG_BINDING objects

	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseButtonDown (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
		


		// return FALSE if not handled
		// return TRUE if handled
		return FALSE;
	}

	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseMove (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
	
		

			

		return FALSE;
	}
	
	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseButtonUp (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
		
		// Note: if we changed data and need to recalculate the flow we need to return TRUE


		// return FALSE if not handled
		// return TRUE if handled
		
		return TRUE;
	}


};

extern "C"
{
	// Plugin factory function
	__declspec(dllexport) IPlugin* Create_Plugin ()
	{
		//allocate a new object and return it
		return new PluginTest ();
	}
	
	// Plugin cleanup function
	__declspec(dllexport) void Release_Plugin (IPlugin* p_plugin)
	{
		//we allocated in the factory with new, delete the passed object
		delete p_plugin;
	}
	
}


// this is the name that will appear in the object library
extern "C" __declspec(dllexport) char* GetPluginName()
{
	
	
	return "!invert";
	
}


// This MUST be unique string for each plugin so we can save the data

extern "C" __declspec(dllexport) char* GetPluginID()
{
	
// 	IMPORTANT:you have to fill unique ID for every plugin:
// 	The ID must be unique or loading and saving will not be able to find correct plugin
//  Comment out this line below so you can compile
//	ATTENTION

	return "com.lumafilters.invert";
	
}


// category of plugin, for now the EFFECT go to top library box, everything else goes to the middle library box
extern "C" __declspec(dllexport) int GetCategory()
{
		
	return CATEGORY_EFFECT;
	
}